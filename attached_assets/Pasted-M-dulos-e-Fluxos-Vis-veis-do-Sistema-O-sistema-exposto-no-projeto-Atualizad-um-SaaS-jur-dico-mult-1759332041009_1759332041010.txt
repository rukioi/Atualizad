Módulos e Fluxos Visíveis do Sistema

O sistema exposto no projeto Atualizad é um SaaS jurídico multi-tenant que disponibiliza diversos módulos para gestão de escritório. A seguir estão os principais módulos e seus fluxos de interface visíveis:

Dashboard: Tela inicial de resumo, exibindo métricas e atalhos. Geralmente permite navegar para outros módulos. (Identificado em Dashboard.tsx).

Clientes (CRM): Gestão de clientes; inclui os fluxos de cadastrar, editar e visualizar clientes. No código, há formulários (ClientForm.tsx), tabela de clientes (ClientsTable.tsx) e diálogo de visualização (ClientViewDialog.tsx) dentro de client/components/CRM e a página CRM.tsx.

Projetos: Gestão de projetos vinculados a clientes. Fluxos de criar, editar e visualizar projetos. Possui também uma visão Kanban (ProjectKanban.tsx) por status. Os componentes ProjectForm.tsx e ProjectViewDialog.tsx lidam com formulário e detalhe. A página principal é Projects.tsx.

Tarefas: Inclui fluxo de criação, edição, visualização de tarefas. Na página Tasks.tsx alterna-se entre visão em lista e em quadro Kanban (TaskBoard.tsx). Cada tarefa pode ter subtarefas (implementadas internamente como JSON no campo subtasks). O formulário de tarefa (TaskForm.tsx) permite adicionar itens de subtarefa. Há também TaskViewDialog.tsx para detalhes.

Fluxo de Caixa (Transações): Gestão de receitas e despesas. Fluxos de lançar nova transação (via TransactionForm.tsx), listar e filtrar transações (TransactionsTable.tsx), e visualizar detalhes (TransactionViewDialog.tsx). As transações incluem categoria, valor, data, método de pagamento etc. Esta área corresponde a CashFlow.tsx.

Cobranças e Faturas (Billing/Recebíveis): Módulos para faturamento. Em Faturas (Billing), o usuário pode criar e enviar faturas (documentos de cobrança) — por exemplo, compondo itens, notas, enviando por e-mail. Componentes como DocumentForm.tsx, DocumentsTable.tsx e EmailSendModal.tsx cuidam da emissão e listagem de faturas. Na área Recebíveis (Receivables.tsx), há integração com Stripe e WhatsApp, permitindo gerar links de pagamento e monitorar pagamentos. Componentes como NewInvoiceModal.tsx e InvoiceViewDialog.tsx permitem criar e visualizar cobranças detalhadas.

Publicações: Gestão de publicações judiciais ou comunicados. A página Publications.tsx lista publicações, e PublicationDetail.tsx mostra detalhes. Funcionalidades incluem registrar nova publicação (informando número de processo, data, conteúdo, fonte, urgência, responsável etc.) e filtrar por cliente ou status.

Notificações: Módulo para exibir notificações do sistema (cobranças vencidas, atualizações de processos, etc.). A página Notifications.tsx mostra alertas ao usuário.

Configurações: Módulo de administrador do tenant, presente em Settings.tsx. Organizado em abas (abertura, segurança, integrações). Permite gerenciar usuários internos, definir chaves de API (e.g. Stripe, WhatsApp, Codilo), controles de acesso, limites de conta e plano contratado. Há componente UserManagement.tsx para criar/remover usuários do tenant.

Esses fluxos formam o “fluxograma textual” do sistema, onde cada módulo permite ações CRUD (criação, leitura, atualização, exclusão) sobre as entidades correspondentes (clientes, projetos, tarefas, transações, faturas, publicações etc.).

*Modelo de Dados e Estruturas SQL Ideais
=
O banco de dados adota multi-tenancy por schema, ou seja, cada cliente (tenant) recebe seu próprio schema isolado. Há tabelas globais e tabelas específicas do schema de cada tenant:

Tabelas por Tenant (em cada schema tenant_<uuid> criado dinamicamente): Cada tenant usa seu próprio schema isolado (conforme a função create_tenant_schema(uuid)). Dentro de cada schema existem, entre outras, as seguintes tabelas principais adaptadas de create_tenant_schema:

users (usuários internos do tenant):
(Verifique se é necessário!)
CREATE TABLE IF NOT EXISTS tenant_x.users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR UNIQUE NOT NULL,
  name VARCHAR NOT NULL,
  phone VARCHAR,
  avatar_url VARCHAR,
  role VARCHAR DEFAULT 'user',
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);


(Nesse caso, esses são os usuários do tenant – possivelmente se integram ao users global.)
(Lembre-se do Pipeline de Vendas --> a tabela também deve ter TUDO que há no a exibição do card UI)

clients:
(Verifique os termos para nao ter conflitos, no UI do cliente ainda falta adicionar "CPF,RG,PIS,CEI, entre outros--> a tabela deve ter TUDO que há no a exibição do card UI")
CREATE TABLE IF NOT EXISTS tenant_x.clients (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR NOT NULL,
  email VARCHAR,
  phone VARCHAR,
  organization VARCHAR,
  address JSONB,
  budget DECIMAL(15,2) DEFAULT 0,
  currency VARCHAR DEFAULT 'BRL',
  status VARCHAR DEFAULT 'active',
  tags TEXT[],
  notes TEXT,
  created_by UUID,            -- pode referenciar tenant_x.users.id
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  is_active BOOLEAN DEFAULT true
);


projects:
(a tabela deve ter TUDO que há no a exibição do card UI)
CREATE TABLE IF NOT EXISTS tenant_x.projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title VARCHAR NOT NULL,
  description TEXT,
  client_id UUID,             -- <option: FK references tenant_x.clients(id)>
  client_name VARCHAR,
  organization VARCHAR,
  address VARCHAR,
  budget DECIMAL(15,2) DEFAULT 0,
  currency VARCHAR DEFAULT 'BRL',
  status VARCHAR DEFAULT 'contacted',
  priority VARCHAR DEFAULT 'medium',
  progress INTEGER DEFAULT 0 CHECK (progress BETWEEN 0 AND 100),
  start_date DATE,
  due_date DATE,
  completed_at TIMESTAMP,
  tags TEXT[],
  assigned_to UUID,           -- <option: FK references tenant_x.users(id)>
  notes TEXT,
  created_by UUID,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  is_active BOOLEAN DEFAULT true
);


tasks:
(a tabela deve ter TUDO que há no a exibição do card UI)
CREATE TABLE IF NOT EXISTS tenant_x.tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title VARCHAR NOT NULL,
  description TEXT,
  project_id UUID,            -- <option: FK references tenant_x.projects(id)>
  project_title VARCHAR,
  client_id UUID,             -- <option: FK references tenant_x.clients(id)>
  client_name VARCHAR,
  assigned_to UUID,           -- <option: FK references tenant_x.users(id)>
  status VARCHAR DEFAULT 'not_started',
  priority VARCHAR DEFAULT 'medium',
  progress INTEGER DEFAULT 0 CHECK (progress BETWEEN 0 AND 100),
  start_date DATE,
  end_date DATE,
  completed_at TIMESTAMP,
  estimated_hours DECIMAL(5,2),
  actual_hours DECIMAL(5,2),
  tags TEXT[],
  notes TEXT,
  subtasks JSONB DEFAULT '[]'::jsonb,  -- lista de subtarefas internas
  created_by UUID,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  is_active BOOLEAN DEFAULT true
);


transactions (Fluxo de Caixa):
(a tabela deve ter TUDO que há no a exibição do card UI)
CREATE TABLE IF NOT EXISTS tenant_x.transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type VARCHAR CHECK (type IN ('income','expense')),
  amount DECIMAL(15,2) NOT NULL,
  category_id VARCHAR,
  category VARCHAR,
  description TEXT NOT NULL,
  date DATE NOT NULL,
  payment_method VARCHAR,
  status VARCHAR DEFAULT 'confirmed',
  project_id UUID,
  project_title VARCHAR,
  client_id UUID,
  client_name VARCHAR,
  tags TEXT[],
  notes TEXT,
  is_recurring BOOLEAN DEFAULT false,
  recurring_frequency VARCHAR,
  created_by UUID,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  is_active BOOLEAN DEFAULT true
);


invoices (Faturamento):
(a tabela deve ter TUDO que há no a exibição do card UI)
CREATE TABLE IF NOT EXISTS tenant_x.invoices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  number VARCHAR UNIQUE NOT NULL,
  title VARCHAR NOT NULL,
  description TEXT,
  client_id UUID,
  client_name VARCHAR,
  client_email VARCHAR,
  client_phone VARCHAR,
  amount DECIMAL(15,2) NOT NULL,
  currency VARCHAR DEFAULT 'BRL',
  status VARCHAR DEFAULT 'draft',
  due_date DATE,
  paid_at TIMESTAMP,
  payment_method VARCHAR,
  items JSONB DEFAULT '[]'::jsonb,   -- itens da fatura
  tags TEXT[],
  notes TEXT,
  created_by UUID,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  is_active BOOLEAN DEFAULT true
);


publications:
(a tabela deve ter TUDO que há no a exibição do card UI)
CREATE TABLE IF NOT EXISTS tenant_x.publications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,      -- advogado responsável (pode referenciar tenant_x.users.id)
  oab_number VARCHAR,
  process_number VARCHAR,
  publication_date DATE,
  content TEXT,
  source VARCHAR,
  external_id VARCHAR,
  status VARCHAR DEFAULT 'nova',
  urgency VARCHAR DEFAULT 'media',
  responsible VARCHAR,
  notes TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(user_id, external_id)  -- evitar duplicação
);


Em todas essas tabelas por tenant sugerimos incluir chaves estrangeiras (FK) adequadas onde faça sentido (por exemplo, tasks.project_id REFERENCES projects(id), tasks.client_id REFERENCES clients(id), projects.client_id REFERENCES clients(id), transactions.client_id REFERENCES clients(id), invoices.client_id REFERENCES clients(id), etc.), para reforçar a integridade referencial e auxiliar buscas otimizadas. Além disso, campos como assigned_to ou created_by podem referenciar usuários internos do tenant. Os índices (CREATE INDEX) já previstos no script SQL auxiliam na performance de consultas frequentes por status, data, usuário, etc.

Para multi-tenant via schema, cada tabela acima reside isoladamente dentro do respectivo schema do tenant (ex.: tenant_1234abcd.clients). Isso garante que os dados de cada cliente não se misturem. Conforme observado na literatura, o esquema por schema “armazena todos os dados dos tenants no mesmo banco, mas em diferentes schemas, proporcionando isolamento de dados”

*Relacionamentos entre Entidades
=
As entidades do modelo relacionam-se da seguinte forma, todas isoladas por schema de tenant:

Um cliente (clients) pode ter vários projetos (projects) e várias tarefas (tasks). O campo projects.client_id e tasks.client_id referenciam o cliente relacionado. Assim, há relacionamento 1:N Cliente→Projetos e Cliente→Tarefas.

Um projeto (projects) pertence a um cliente (via client_id) e pode ter várias tarefas (tasks.project_id refere o projeto). Relação 1:N Projeto→Tarefas.

Uma tarefa (tasks) pode conter várias subtarefas, mas no modelo atual essas são armazenadas em um campo JSON (subtasks). Uma melhoria seria criar uma tabela subtasks separada para relacionar 1:N Tarefa→Subtarefas. Atualmente, cada registro de tarefa incorpora internamente suas subtarefas.

Usuários do tenant (users do schema) podem ser atribuídos a tarefas (tasks.assigned_to) e são responsáveis por publicações (publications.user_id). Assim, 1:N Usuário→Tarefas e Usuário→Publicações.

Uma fatura (invoices) refere-se a um único cliente (client_id), de forma N:1. O sistema permite gerar várias faturas para um cliente. Não há tabela separada para itens; eles estão em JSON no campo items.

Uma transação financeira (transactions) pode estar ligada a um projeto e/ou cliente (project_id, client_id). Permite N:1 Projetos→Transações e N:1 Clientes→Transações.

Publicações (publications) incluem o código OAB do advogado (oab_number) e número de processo, mas não referenciam diretamente clientes ou projetos, apenas o usuário responsável.

Todas essas tabelas de tenant existem em schemas distintos (e.g. tenant_{uuid}), garantindo isolamento de dados entre clientes. Como sugere a prática de multi-tenancy, cada tenant trabalha em seu próprio namespace de tabelas.

VERIFIQUE SE ESTA TUDO DE ACORDO COM MEU SISTEMA! TOME MUITO CUIDADO COM OS TERMOS PARA NAO ADICIONAR OS MESMOS TERMOS (exemplo: nome e name) EM CAMPOS DIFERENTES E GERAR CONFUSÃO! Tente padronizar! Faça com maestria! Você é um PROFISSIONAL DE BANCO DE DADOS COM MAIS DE 20ANOS DE EXPERIÊNCIA e um PROFISSIONAL EM IMPLEMENTAÇÃO BACKEND