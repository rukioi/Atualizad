Plano de Implementação: Próximas etapas (tarefas)

Para iniciar a implementação completa dos CRUDs (removendo mocks), recomendo seguir etapas em fases – inspiradas na metodologia do plano geral:

Revisão Inicial e Modelagem (Preparação):

Verifique que os models do Prisma contêm todos os campos necessários para o módulo (por exemplo, confira se Project tem os campos stage, budget, etc.). Se faltar algo (como campos de relacionamentos), atualize o schema e gere a migração.

Analise os relacionamentos (foreign keys): certifique que tabelas relacionadas (ex: Task ➔ Project, Invoice ➔ Client) estão devidamente mapeadas no Prisma.

Atualize ou crie interfaces TypeScript no front-end para refletir exatamente os tipos retornados pelo back-end (veja client/src/types/crm.ts). Sincronize nomes de campos (p.ex. contactName vs contact_name) ou converta-os se necessário.

Backend – Ajustes de Service/Controller/Routes:

Serviços: Confirme que o serviço do módulo está completo. Já existe, por exemplo, projectsService.ts para Pipeline de Vendas. Se não existir algum serviço (módulos futuros), siga o template de clientsService.ts (queries usando helpers de tenant). Adicione handles de agregação ou contagem se o módulo precisar (conforme checklist do documento).

Controllers: Verifique se há validações Zod para todas as operações (criar, editar, buscar, excluir). Se não, crie schemas Zod similar aos de clientes. Garanta que campos obrigatórios estão corretos. Implemente ou ajuste funções no controller (por exemplo, createProject, getProjects, updateProject, deleteProject) chamando o serviço.

Rotas: Confira que as rotas REST estão definidas (/projects, /projects/:id, etc.) no Express e usam authenticateToken e tenantMiddleware conforme padrão. Teste com ferramentas (Postman/Thunder) para garantir que o endpoint responde conforme esperado e que retornam os objetos JSON corretos.

Frontend – Hooks e Conexão de UI:

Remover Mock Data: Em cada página que ainda usa dados estáticos (por exemplo, arrays mockClients, mockDeals no client/pages/CRM.tsx), elimine esses blocos. No lugar, utilize o hook apropriado. Por exemplo, para Pipeline, use o useProjects já existente (ou crie um se faltar) para carregar a lista de negócios do back-end.

Ganchos (Hooks): Se ainda não existir hook para o módulo (ex: useInvoices, useTasks, usePublications), crie-o espelhando useProjects. No hook, use o apiService para chamar o endpoint correto (getInvoices(), getTasks(), etc.), e gerencie estado de loading e erros. Mantenha o padrão de capturar erros e lançar exceções conforme os outros.

Integração com componentes: Substitua nas páginas ou componentes as referências aos mocks pelos dados do hook. Por exemplo, no CRM (Pipeline), passe projects ao componente <Pipeline> (talvez mapeando objetos Project para a interface Deal do front-end). Utilize as funções do hook (createProject, updateProject, deleteProject) nos handlers onAddDeal, onEditDeal e onDeleteDeal do Pipeline, garantindo recarregar a lista após alterações.

Formulários e Tabelas: Certifique-se de que os componentes de formulário (ex: DealForm.tsx, ClientForm.tsx) enviam dados no formato correto para a API. Ajuste validação do React Hook Form para refletir o Zod schema do back-end se necessário. Para tabelas (e.g. ClientsTable, TasksTable), retire o estado fictício e consuma os dados reais do hook. Remova também filtros e buscas dummy, substituindo por chamadas reais (apiService via hook) ou parâmetros na URL.

Testes e Ajustes Finais:

Funcionalidade Completa: Depois de integrar front e back, teste todos os fluxos (criar, listar, editar, deletar). Verifique que, por exemplo, um cliente criado aparece na lista e persiste no banco. Use as rotas do back-end diretamente para confirmar retornos.

Validação e Erros: Observe mensagens de erro padrão (por exemplo, token expirado, “Tenant access denied”, “JSON parse error” descritos na documentação). Corrija qualquer inconsistência (p.ex. uma resposta 404 pode indicar rota duplicada ou mal configurada).

Multi-Tenant: Garanta que cada operação considere o schema do tenant atual. Isso normalmente está tratado pelo middleware e helpers de banco, mas valide inserções e leituras em múltiplos bancos/tenants se possível.

Desempenho e Escalabilidade: Embora seja um MVP, atente-se a pontos como paginação de listagens extensas ou caching simples se recomendado para métricas (dashboard) após a CRUD básico funcionar.